---
description: Laravel Clean Architecture rules for this project
globs: ["app/**/*.php", "tests/**/*.php"]
alwaysApply: true
---

# Laravel Clean Architecture - Cursor Rules

## ğŸ—ï¸ Project Structure

This project follows **Strict Clean Architecture** pattern.

```
app/
â”œâ”€â”€ Domain/              # Pure PHP - NO framework dependencies
â”œâ”€â”€ Application/         # Use Cases, DTOs - NO framework dependencies  
â”œâ”€â”€ Infrastructure/      # Laravel implementations
â”œâ”€â”€ Http/               # Presentation layer (Controllers, Requests, Resources)
â”œâ”€â”€ Shared/             # Common code (Constants, Enums, Helpers)
â””â”€â”€ Console/            # CLI Commands
```

## ğŸ“‹ Layer Rules

### Domain Layer (`app/Domain/`)
- âŒ NEVER use Laravel/Illuminate classes
- âŒ NEVER use `config()`, `env()`, `__()` functions
- âœ… Use only PHP core classes (DateTimeImmutable, Exception, etc.)
- âœ… Use interfaces from `App\Shared\Constants\`
- Contains: Entities, ValueObjects, Repository Interfaces, Service Interfaces, Domain Exceptions

### Application Layer (`app/Application/`)
- âŒ NEVER use Laravel/Illuminate classes
- âŒ NEVER use Eloquent models directly
- âœ… Use Domain interfaces (injected via constructor)
- âœ… Use DTOs for data transfer
- Contains: UseCases, DTOs

### Infrastructure Layer (`app/Infrastructure/`)
- âœ… Can use Laravel/Illuminate classes
- âœ… Implements Domain interfaces
- Contains: Eloquent Models, Repositories, Services, Providers, Logging, Mail

### Http Layer (`app/Http/`)
- âœ… Can use Laravel classes
- âœ… Uses Domain Service interfaces (not implementations)
- Contains: Controllers, Requests, Resources, Middleware, Rules, Exceptions, Swagger

### Shared Layer (`app/Shared/`)
- âœ… Pure PHP constants and enums (can be used by Domain)
- âœ… Helpers (may use Laravel - only for Infrastructure/Http use)
- Contains: Constants, Enums, Helpers

## ğŸ“ Naming Conventions

### Files & Classes
- Entities: `User.php`, `PasswordResetToken.php`
- DTOs: `LoginDTO.php`, `CreateUserDTO.php`
- UseCases: `LoginUseCase.php`, `CreateUserUseCase.php`
- Interfaces: `UserRepositoryInterface.php`, `AuthServiceInterface.php`
- Implementations: `EloquentUserRepository.php`, `LaravelMailService.php`
- Models: `UserModel.php`, `PasswordResetTokenModel.php`
- Mappers: `UserMapper.php`
- Controllers: `AuthController.php`, `UserController.php`

### Methods
- UseCases: `execute()` method
- Repositories: `findById()`, `findByField()`, `create()`, `update()`, `delete()`, `list()`
- DTOs: `fromArray()`, `toArray()`
- Entities: `toArray()`, business logic methods

### Constants
- Date formats: `DateFormat::DATETIME_Y_m_d_H_i_s`
- Enums: `UserStatus::ACTIVE`, `UserRole::ADMIN`

## ğŸ”„ Data Flow

```
Request â†’ Controller â†’ Service â†’ UseCase â†’ Repository â†’ Database
                â†“
           Response â† Resource â† Entity/DTO
```

## ğŸ“¦ Dependency Injection

Always inject interfaces, not implementations:

```php
// âœ… Good
public function __construct(
    protected UserRepositoryInterface $userRepository,
    protected HashServiceInterface $hashService,
) {}

// âŒ Bad
public function __construct(
    protected EloquentUserRepository $userRepository,
) {}
```

## ğŸ—‚ï¸ File Templates

### Entity (Domain)
```php
<?php

namespace App\Domain\Entities;

use App\Shared\Constants\DateFormat;
use DateTimeImmutable;

readonly class EntityName
{
    public function __construct(
        public ?int $id,
        // properties...
    ) {}

    public function toArray(): array
    {
        return [
            'id' => $this->id,
            // ...
        ];
    }
}
```

### UseCase (Application)
```php
<?php

namespace App\Application\UseCases\Feature;

use App\Domain\Repositories\SomeRepositoryInterface;

class DoSomethingUseCase
{
    public function __construct(
        protected SomeRepositoryInterface $repository,
    ) {}

    public function execute(SomeDTO $dto): mixed
    {
        // Business logic here
    }
}
```

### DTO (Application)
```php
<?php

namespace App\Application\DTOs\Feature;

readonly class SomeDTO
{
    public function __construct(
        public string $field1,
        public string $field2,
    ) {}

    public static function fromArray(array $data): self
    {
        return new self(
            field1: $data['field1'],
            field2: $data['field2'],
        );
    }

    public function toArray(): array
    {
        return [
            'field1' => $this->field1,
            'field2' => $this->field2,
        ];
    }
}
```

### Repository Interface (Domain)
```php
<?php

namespace App\Domain\Repositories;

use App\Domain\Entities\EntityName;

interface EntityRepositoryInterface
{
    public function findById(int $id): ?EntityName;
    public function create(array $data): EntityName;
    public function update(array $data, int $id): EntityName;
    public function delete(int $id): bool;
}
```

### Repository Implementation (Infrastructure)
```php
<?php

namespace App\Infrastructure\Repositories;

use App\Domain\Entities\EntityName;
use App\Domain\Repositories\EntityRepositoryInterface;
use App\Infrastructure\Persistence\Eloquent\Mappers\EntityMapper;
use App\Infrastructure\Persistence\Eloquent\Models\EntityModel;

class EloquentEntityRepository implements EntityRepositoryInterface
{
    public function __construct(
        protected EntityModel $model,
    ) {}

    public function findById(int $id): ?EntityName
    {
        $model = $this->model->query()->find($id);
        return $model ? EntityMapper::toEntity($model) : null;
    }
}
```

## âš™ï¸ Configuration

- Date formats: Use `App\Shared\Constants\DateFormat::*`
- App config: Use `ConfigServiceInterface` in Application layer
- Direct config: Only in Infrastructure/Http layers

## ğŸ§ª Testing Structure

```
tests/
â”œâ”€â”€ Unit/
â”‚   â”œâ”€â”€ Domain/Entities/
â”‚   â”œâ”€â”€ Domain/ValueObjects/
â”‚   â”œâ”€â”€ Application/DTOs/
â”‚   â””â”€â”€ Application/UseCases/
â””â”€â”€ Feature/
    â””â”€â”€ Http/Controllers/Api/V1/
```

## ğŸš« Anti-Patterns to Avoid

1. âŒ Using Eloquent in Domain/Application layers
2. âŒ Using `config()` in Domain/Application layers
3. âŒ Injecting concrete classes instead of interfaces
4. âŒ Business logic in Controllers
5. âŒ Hardcoded values (use Constants/Config)
6. âŒ Direct database queries in UseCases

## âœ… Best Practices

1. âœ… Keep Domain layer pure PHP
2. âœ… Use Mappers to convert Model â†” Entity
3. âœ… One UseCase = One business action
4. âœ… DTOs are immutable (readonly)
5. âœ… Entities contain business logic methods
6. âœ… Register bindings in CleanArchitectureServiceProvider
